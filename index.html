<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b0f14" />
  <link rel="manifest" href="./manifest.webmanifest?v=2" />
  <link rel="icon" href="./favicon.ico" />
  <title>Don's Inventory Tracker</title>

  <!-- Supabase client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.4/dist/umd/supabase.js"></script>

  <!-- Optional: set your Supabase URL and anon key here -->
  <script>
    // Supabase project credentials (safe to expose anon public key in client)
    window.SB_URL  = "https://entmbaxeylglposptsuy.supabase.co";
    window.SB_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVudG1iYXhleWxnbHBvc3B0c3V5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY5MTQ2NjEsImV4cCI6MjA3MjQ5MDY2MX0.vDTzhL0Q-iDZShWu2hcaYOavPLltY31OThXj-ohBjAc";
  </script>

  <script>
  // Lightweight observability: log JS errors so users can screenshot
  window.addEventListener('error', e => console.log('JS Error:', e.message, e.error));
  window.addEventListener('unhandledrejection', e => console.log('Promise Rejection:', e.reason));
  </script>

  <style>
    :root{
      --bg:#24292d;--fg:#eaeff7;--muted:#a9b4c0;--accent:#5aa9ff;
      --card:#000000;--border:#1f2a36
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      background:var(--bg);color:var(--fg)
    }
    header{
      padding:calc(14px + env(safe-area-inset-top)) 16px 14px;
      border-bottom:1px solid var(--border);
      position:sticky;top:0;background:var(--bg);z-index:20;text-align:center;
    }
.ver{display:inline-block;margin-left:8px;padding:2px 8px;border-radius:999px;background:#0d1420;color:#9fb3c8;font-size:12px;border:1px solid var(--border);vertical-align:middle}
    h1{font-size:24px;margin:0}
    main{padding:12px;max-width:1100px;margin:0 auto}
    .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:12px}
    .toolbar{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .toolbar .spacer{flex:1}
    .btn{
      cursor:pointer;border:1px solid var(--border);background:#101826;color:#fff;
      padding: clamp(10px, 2.2vw, 12px) clamp(12px, 3vw, 14px);
      border-radius:10px;font-weight:600;
      font-size: clamp(14px, 2.8vw, 16px);
      line-height:1.1; white-space:nowrap; min-height:44px
    }
    .btn.primary{background:var(--accent);color:#06121f;border-color:transparent}
    .btn:disabled{ opacity:.55; cursor:not-allowed }
    .muted{color:var(--muted);font-size:12px}
    .time{font-size:12px;color:var(--muted)}
    .scroll{overflow:auto;max-height:70vh;border-radius:10px;position:relative;-webkit-overflow-scrolling:touch;overscroll-behavior:contain}
    table{width:100%;border-collapse:collapse;font-size:15px}
    thead th{
      text-align:left;color:var(--muted);font-weight:600;border-bottom:1px solid var(--border);
      padding:12px;position:sticky;top:0;background:var(--card);z-index:7;box-shadow:0 2px 0 rgba(0,0,0,.2)
    }
    tbody td{padding:12px;border-bottom:1px solid var(--border);vertical-align:middle}
    td.qty{text-align:right;font-variant-numeric:tabular-nums}
    th.sel, td.sel{ width:42px; text-align:center }
    input[type=text],input[type=number],textarea{
      width:100%;padding:12px;border-radius:10px;border:1px solid var(--border);
      background:#0d131b;color:#fff;font-size:16px
    }
    #filterBox{
      flex:1; min-width:160px; max-width:320px;
      padding:12px;border-radius:10px;border:1px solid var(--border);
      background:#0d131b;color:#eaeff7;font-size:16px
    }
    td.editing{padding:6px}
    .toast{
      position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:#0d1420;
      border:1px solid var(--border);color:var(--fg);padding:10px 14px;border-radius:10px;
      box-shadow:0 10px 30px rgba(0,0,0,.4);z-index:100;display:none
    }
    .modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,.5);z-index:200}
    .modal .box{
      max-width:580px;margin:10vh auto;background:var(--card);border:1px solid var(--border);
      border-radius:14px;padding:14px
    }
    .drop{
      border:1px dashed var(--border);border-radius:10px;padding:12px;text-align:center;color:var(--muted)
    }
    @media (max-width:640px){
      .toolbar{gap:6px}
      .toolbar .btn{flex:1}
      .scroll{max-height:calc(100vh - 240px)}
    }
    @media (max-width:360px){ .toolbar{gap:4px} }
  </style>
</head>
<body>
  <header><h1>Don's Inventory Tracker <span class="ver" id="verBadge"></span></h1></header>

  <main>
    <section class="card">
      <div class="toolbar" role="toolbar" aria-label="Inventory actions">
        <input type="file" id="fileImport" accept=".csv,.tsv,.txt,.json,.xlsx,.xls,.docx,.doc" style="display:none" />
        <button class="btn" id="btnImport">Import File</button>
        <button class="btn" id="btnPaste">Paste Data</button>
        <button class="btn" id="btnExportCsv">Export File</button>
        <button class="btn" id="btnAddOne">Add Item</button>
        <button class="btn" id="btnDeleteSelected">Delete Selected</button>
        <button class="btn" id="btnUndo" disabled>Undo</button>
        <input id="filterBox" type="text" placeholder="Filter itemsâ€¦" aria-label="Filter items" />
        <span class="spacer"></span>
        <span class="time" id="lastUpdate" aria-live="polite"></span>
      </div>

      <div class="scroll" id="tableWrap">
        <table id="invTable" role="grid" aria-label="Inventory table">
          <thead>
            <tr>
              <th class="sel"><input type="checkbox" id="chkAll" aria-label="Select all"></th>
              <th scope="col">Item</th>
              <th scope="col">Description</th>
              <th scope="col" class="qty">Qty</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div class="muted" style="margin-top:8px">
        Tap any cell to edit inline; <kbd>Enter</kbd> saves, <kbd>Esc</kbd> cancels.
      </div>
    </section>
  </main>

  <!-- Paste/Import modal -->
  <div id="pasteModal" class="modal" aria-hidden="true">
    <div class="box">
      <h2 style="margin:0 0 10px;font-size:16px;">Paste Data</h2>
      <div class="muted" style="margin-bottom:10px;">
        Provide columns <code>Item, Description, Qty</code>. Headers optional; Qty optional (defaults to 0).
        Tabs, commas, or multi-space columns are accepted. You may also drop or choose a file.
      </div>
      <div class="drop" id="dropZone">Drop a CSV/TSV/TXT/JSON/XLSX/XLS/DOCX file here, or choose below.</div>
      <input type="file" id="fileImportModal" accept=".csv,.tsv,.txt,.json,.xlsx,.xls,.docx,.doc" style="display:block;margin:10px 0;" />
      <textarea id="pasteArea" rows="8" placeholder="Item, Description, Qty"></textarea>
      <div class="toolbar" style="margin-top:10px;justify-content:flex-end;">
        <span id="pasteInfo" class="muted" style="margin-right:auto"></span>
        <button class="btn" id="btnPasteCancel">Cancel</button>
        <button class="btn primary" id="btnPasteApply">Import</button>
      </div>
    </div>
  </div>

  <!-- Add-one modal -->
  <div id="addOneModal" class="modal" aria-hidden="true">
    <div class="box">
      <h2 style="margin:0 0 10px;font-size:16px;">Add Item</h2>
      <div style="display:grid; grid-template-columns:1fr; gap:8px;">
        <label class="muted">Item (unique)</label>
        <input id="addName" type="text" placeholder="Item" autocapitalize="off" autocomplete="off" spellcheck="false" />
        <label class="muted">Description (optional)</label>
        <input id="addDesc" type="text" placeholder="Description" />
        <label class="muted">Qty (integer > 0)</label>
        <input id="addQty" type="number" min="1" step="1" pattern="[0-9]*" inputmode="numeric" enterkeyhint="done" />
      </div>
      <div class="toolbar" style="margin-top:10px;justify-content:flex-end;">
        <button class="btn" id="btnAddCancel">Cancel</button>
        <button class="btn primary" id="btnAddSave">Save</button>
      </div>
    </div>
  </div>

  <!-- Import preview -->
  <div id="previewModal" class="modal" aria-hidden="true">
    <div class="box">
      <h2 style="margin:0 0 10px;font-size:16px;">Import Preview</h2>
      <div class="muted" id="previewInfo" style="margin-bottom:10px"></div>
      <div class="scroll" style="max-height:50vh">
        <table style="width:100%;border-collapse:collapse;font-size:14px">
          <thead>
            <tr>
              <th style="text-align:left;padding:8px;border-bottom:1px solid var(--border)">Item</th>
              <th style="text-align:left;padding:8px;border-bottom:1px solid var(--border)">Description</th>
              <th style="text-align:right;padding:8px;border-bottom:1px solid var(--border)">Old Qty</th>
              <th style="text-align:right;padding:8px;border-bottom:1px solid var(--border)">New Qty</th>
              <th style="text-align:left;padding:8px;border-bottom:1px solid var(--border)">Action</th>
            </tr>
          </thead>
          <tbody id="previewBody"></tbody>
        </table>
      </div>
      <div class="toolbar" style="margin-top:10px;justify-content:flex-end;">
        <button class="btn" id="btnPreviewCancel">Cancel</button>
        <button class="btn primary" id="btnPreviewApply">Apply Import</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>

  <script>
    // ========================
    // State & persistence
    // ========================
    const DB_KEY='inv.single.inline.mobile.v1';
    const state={items:[], updatedAt:null, _filter:'', _undoStack:[]};
    const APP_VERSION = '1.0.0';

    const $ = (id) => document.getElementById(String(id).replace(/^#/, ''));
    const toKey=s=>(s||'').trim().toUpperCase();
    function toInt(v,f=0){const n=Number(v); if(!Number.isFinite(n))return f; const i=Math.floor(n); return i<0?f:i;}
    function setUpdated(){ state.updatedAt=new Date().toISOString(); }
    function save(){ localStorage.setItem(DB_KEY, JSON.stringify(state)); render(); }
    function load(){ const raw=localStorage.getItem(DB_KEY); if(raw){ try{const p=JSON.parse(raw); if(p&&Array.isArray(p.items)) Object.assign(state,p);}catch{}} }
    function dedupe(){
      const seen=new Set();
      state.items=state.items.filter(it=>{
        const k=toKey(it.name); if(!k) return false;
        if(seen.has(k)) return false;
        seen.add(k);
        if(!it.id) it.id=crypto.randomUUID();
        it.qty = toInt(it.qty,0);
        return true;
      });
    }

    // Shallow clone of items for optimistic-UI rollback
    function snapshotItems(){ return state.items.map(it => ({...it})); }

    // ========================
    // Supabase (cloud sync) â€” optional
    // ========================
    const SB = { client:null, ready:false };
    function sbInit(){
      const url = window.SB_URL, key = window.SB_ANON;
      if(!url || !key || SB.client){ return; }
      SB.client = window.supabase.createClient(url, key);
      SB.ready = true;
    }
    async function sbLoadSnapshot(){
      if(!SB.ready) return;
      const { data, error } = await SB.client
        .from('items')
        .select('id,name,description,qty,updated_at')
        .order('name', { ascending:true });
      if(error){ console.warn('Supabase load error', error); return; }
      state.items = (data||[]).map(r => ({
        id:r.id, name:r.name||'', desc:r.description||'', qty:toInt(r.qty,0), updatedAt:r.updated_at||null
      }));
      setUpdated(); render();
    }
    let _sbChannel=null;
    function sbStartRealtime(){
      if(!SB.ready) return;
      if(_sbChannel){ SB.client.removeChannel(_sbChannel); _sbChannel=null; }
      _sbChannel = SB.client.channel('items_all')
        .on('postgres_changes', {event:'*', schema:'public', table:'items'}, payload=>{
          const row = payload.new || payload.old;
          if(payload.eventType==='INSERT'){
            const i = state.items.findIndex(x=> x.id===row.id);
            if(i===-1) state.items.push({id:row.id,name:row.name,desc:row.description||'',qty:toInt(row.qty,0),updatedAt:row.updated_at});
          }else if(payload.eventType==='UPDATE'){
            const it = state.items.find(x=> x.id===row.id);
            if(it){ it.name=row.name; it.desc=row.description||''; it.qty=toInt(row.qty,0); it.updatedAt=row.updated_at; }
          }else if(payload.eventType==='DELETE'){
            state.items = state.items.filter(x=> x.id!==row.id);
          }
          setUpdated(); render();
        })
        .subscribe();
    }
    async function sbAddItem(name, desc, qty){
      const id = crypto.randomUUID();
      const { error } = await SB.client.from('items').insert([{ id, name, description:desc||'', qty:toInt(qty,0) }]);
      if(error) throw error; return id;
    }
    async function sbUpdateFields(id, fields){
      const clean = {};
      if('name' in fields) clean.name = String(fields.name||'');
      if('desc' in fields) clean.description = String(fields.desc||'');
      if('qty'  in fields) clean.qty  = toInt(fields.qty,0);
      const { error } = await SB.client.from('items').update(clean).eq('id', id);
      if(error) throw error;
    }
    async function sbDeleteMany(ids){
      const requested = Array.isArray(ids) ? ids.filter(Boolean) : [];
      if(requested.length===0) return { deleted:0, requested:0 };
      const { data, error } = await SB.client
        .from('items')
        .delete()
        .in('id', requested)
        .select('id'); // return deleted rows for verification
      if (error) throw error;
      const deleted = (data||[]).map(r=> r.id);
      const missing = requested.filter(id => !deleted.includes(id));
      if (missing.length){
        throw new Error('Server did not delete some ids: '+missing.join(', '));
      }
      return { deleted: deleted.length, requested: requested.length };
    }
    async function sbUpsertMany(rows){
      // Load existing rows to build a case-insensitive index by name
      const { data: existing, error: selErr } = await SB.client
        .from('items')
        .select('id,name,description,qty');
      if (selErr) throw selErr;

      const idx = new Map((existing||[]).map(it => [toKey(it.name), it]));
      const toInsert = [];
      const toUpdate = [];

      for (const r of rows){
        const k = toKey(r.name); if (!k) continue;
        const ex = idx.get(k);
        const name = String(r.name||'').trim();
        const description = String(r.desc||'').trim();
        const qty = toInt(r.qty,0);

        if (!ex){
          toInsert.push({ name, description, qty });
        } else {
          toUpdate.push({ id: ex.id, name, description: (description || ex.description || ''), qty });
        }
      }

      if (toInsert.length){
        const { error: insErr } = await SB.client.from('items').insert(toInsert);
        if (insErr) throw insErr;
      }
      // Upsert updates by primary key id (safe and efficient)
      if (toUpdate.length){
        // Chunk to avoid payload limits
        const chunks = [];
        const size = 500;
        for (let i=0;i<toUpdate.length;i+=size) chunks.push(toUpdate.slice(i, i+size));
        for (const part of chunks){
          const { error: upErr } = await SB.client.from('items').upsert(part, { onConflict: 'id' });
          if (upErr) throw upErr;
        }
      }
    }

    // ========================
    // Rendering & inline edit
    // ========================
    function escapeHtml(s){ return String(s).replace(/[&<>]/g, c=> ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
    function render(){ renderTable(); renderKpis(); refreshUndo(); }
    function renderKpis(){
      const el=$('lastUpdate');
      if(!el) return;
      el.textContent = state.updatedAt? `Last Update: ${new Date(state.updatedAt).toLocaleString(undefined,{hour12:true})}` : '';
      const fb=$('filterBox'); if(fb) fb.value = state._filter || '';
      const vb=$('verBadge'); if(vb) vb.textContent = APP_VERSION;
    }

    // -------- Partial-optimistic DOM helpers --------
function tbodyEl(){ return document.querySelector('#invTable tbody'); }
function rowElById(id){ return tbodyEl()?.querySelector(`tr[data-id="${id}"]`) || null; }
function cellEl(tr, col){ return tr?.querySelector(`td[data-col="${col}"]`) || null; }
function buildRowHTML(it){
  return (
    '<td class="sel"><input type="checkbox" class="rowChk" data-id="'+it.id+'"></td>'+
    '<td data-col="name">'+escapeHtml(it.name||'')+'</td>'+
    '<td data-col="desc">'+escapeHtml(it.desc||'')+'</td>'+
    '<td data-col="qty" class="qty">'+toInt(it.qty,0)+'</td>'
  );
}
// Insert a row into the table in sorted position by name
function insertRowSorted(it){
  const tb = tbodyEl(); if(!tb) return;
  const empty = tb.querySelector('tr[data-empty="1"]'); if(empty) empty.remove();
  const trs = Array.from(tb.querySelectorAll('tr[data-id]'));
  const k = toKey(it.name);
  let anchor = null;
  for(const tr of trs){
    const nm = tr.querySelector('td[data-col="name"]')?.textContent || '';
    if(toKey(nm) > k){ anchor = tr; break; }
  }
  const tr = document.createElement('tr');
  tr.dataset.id = it.id;
  tr.innerHTML = buildRowHTML(it);
  if(anchor) tb.insertBefore(tr, anchor); else tb.appendChild(tr);
  enableInlineEditing(); // attach listeners to the new row
}
// Reposition existing row if its name changed
function repositionRowByName(id){
  const tb = tbodyEl(); if(!tb) return;
  const tr = rowElById(id); if(!tr) return;
  const it = state.items.find(x=> x.id===id); if(!it) return;
  tr.innerHTML = buildRowHTML(it); // refresh cells
  const others = Array.from(tb.querySelectorAll('tr[data-id]')).filter(x=> x!==tr);
  const k = toKey(it.name);
  let anchor = null;
  for(const r of others){
    const nm = r.querySelector('td[data-col="name"]')?.textContent || '';
    if(toKey(nm) > k){ anchor = r; break; }
  }
  if(anchor) tb.insertBefore(tr, anchor); else tb.appendChild(tr);
  enableInlineEditing();
}
// Update just one cell
function updateCellDisplay(id, col, value){
  const tr = rowElById(id); if(!tr) return;
  const td = cellEl(tr, col); if(!td) return;
  td.textContent = (col==='qty') ? toInt(value,0) : String(value||'');
}
// Ensure an empty-state row exists when there are no data rows
function ensureEmptyState(){
  const tb = tbodyEl(); if(!tb) return;
  const hasRows = tb.querySelector('tr[data-id]') !== null;
  const existingEmpty = tb.querySelector('tr[data-empty="1"]');
  if(!hasRows && !existingEmpty){
    const tr=document.createElement('tr'); tr.setAttribute('data-empty','1');
    tr.innerHTML = '<td colspan="4" style="padding:16px;text-align:center;color:var(--muted)">No items yet. Use <b>Import File</b> or <b>Paste Data</b> above, or <b>Add Item</b> to create one.</td>';
    tb.appendChild(tr);
  } else if(hasRows && existingEmpty){
    existingEmpty.remove();
  }
}
    function renderTable(){
      const tbody=$('#invTable').querySelector('tbody'); tbody.innerHTML='';
      const term=(state._filter||'').trim().toLowerCase();

      let items=[...state.items].sort((a,b)=> toKey(a.name).localeCompare(toKey(b.name)));
      if(term){
        items = items.filter(it=>{
          const name=(it.name||'').toLowerCase();
          const desc=(it.desc||'').toLowerCase();
          const qty = String(toInt(it.qty,0));
          return name.includes(term) || desc.includes(term) || qty.includes(term);
        });
      }
      if(items.length===0){
      const tr=document.createElement('tr');
      tr.innerHTML = '<td colspan="4" style="padding:16px;text-align:center;color:var(--muted)">No items yet. Use <b>Import File</b> or <b>Paste Data</b> above, or <b>Add Item</b> to create one.</td>';
      tbody.appendChild(tr);
      return;
      }
      for(const it of items){
        const tr=document.createElement('tr'); tr.dataset.id=it.id;
        tr.innerHTML =
          '<td class="sel"><input type="checkbox" class="rowChk" data-id="'+it.id+'"></td>'+
          '<td data-col="name">'+escapeHtml(it.name||'')+'</td>'+
          '<td data-col="desc">'+escapeHtml(it.desc||'')+'</td>'+
          '<td data-col="qty" class="qty">'+toInt(it.qty,0)+'</td>';
        tbody.appendChild(tr);
      }
      enableInlineEditing();
    }
    function refreshUndo(){
    const b=$('btnUndo');
    const n = state._undoStack.length;
    if(b){
    b.disabled = n===0;
    b.textContent = n>0 ? `Undo (${n})` : 'Undo';
    }
    }

    function enableInlineEditing(){
      const tbody=$('#invTable').querySelector('tbody');
      tbody.querySelectorAll('td').forEach(td=>{
        if(td.classList.contains('sel')) return; // skip checkbox column
        td.addEventListener('click', ()=> startCellEdit(td));
        td.addEventListener('dblclick', ()=> startCellEdit(td));
      });
    }

    function pushUndo(it, col, oldVal){
      state._undoStack.push({ id: it.id, col, old: oldVal, when: Date.now() });
      if(state._undoStack.length > 5) state._undoStack.shift();
      refreshUndo();
      }
      
     function doUndo(){
      const u = state._undoStack.pop();
      if(!u){ refreshUndo(); return; }
      const it = state.items.find(x=> x.id===u.id);
      if(!it){ refreshUndo(); return; }
      if(u.col==='name') it.name = String(u.old);
      else if(u.col==='desc') it.desc = String(u.old);
      else if(u.col==='qty') it.qty = toInt(u.old,0);
      setUpdated(); save(); refreshUndo(); toast('Undone');
     }

    $('btnUndo').addEventListener('click', doUndo);

    function startCellEdit(td){
      if(td.querySelector('input')) return;
      const col=td.getAttribute('data-col'); if(!col) return;
      const tr=td.closest('tr'); const id=tr.dataset.id; const it=state.items.find(x=> x.id===id); if(!it) return;
      const fb = $('filterBox'); if (fb) fb.value = '';
      state._filter = '';
      const oldVal = (col==='qty'? String(toInt(it.qty,0)) : String(col==='name'?it.name:(it.desc||'')));
      pushUndo(it, col, (col==='qty'? toInt(it.qty,0) : (col==='name'? it.name : (it.desc||''))));
      const inp=document.createElement('input');
      inp.type = (col==='qty')? 'number' : 'text';
      if(col==='qty'){ inp.min='0'; inp.step='1'; inp.inputMode='numeric'; inp.pattern='[0-9]*'; inp.setAttribute('enterkeyhint','done'); }
      inp.value = oldVal; inp.autocapitalize='off'; inp.autocomplete='off'; inp.spellcheck=false;
      td.classList.add('editing'); td.innerHTML=''; td.appendChild(inp);
      setTimeout(()=>{ inp.focus(); inp.select(); }, 0);

      const cancel=()=>{ td.classList.remove('editing'); td.innerHTML = (col==='qty')? toInt(it.qty,0) : escapeHtml(col==='name'?it.name:(it.desc||'')); };

      const commit = async () => {
        let v = inp.value;
        // Build validation and normalized values
        try{
          const snapshot = { name: it.name, desc: it.desc, qty: it.qty };
          if(col==='name'){
            v=String(v).trim(); if(!v) throw Error('Name required');
            // Prevent local dupes (case-insensitive)
            if(toKey(v)!==toKey(it.name) && state.items.some(x=> x!==it && toKey(x.name)===toKey(v))) throw Error('Duplicate name');
            // Optimistic update
            it.name = v; setUpdated(); save(); renderTable();
            if(SB.ready){ await sbUpdateFields(id, { name:v }); }
          }else if(col==='desc'){
            const nv = String(v).trim();
            it.desc = nv; setUpdated(); save(); renderTable();
            if(SB.ready){ await sbUpdateFields(id, { desc:nv }); }
          }else if(col==='qty'){
            const q=toInt(v,-1); if(q<0) throw Error('Qty must be integer â‰¥ 0');
            it.qty = q; setUpdated(); save(); renderTable();
            if(SB.ready){ await sbUpdateFields(id, { qty:q }); }
          }
          // success: leave cell as rendered
        }catch(e){
          // rollback UI on error
          it.name = snapshot?.name ?? it.name;
          it.desc = snapshot?.desc ?? it.desc;
          it.qty  = toInt(snapshot?.qty ?? it.qty,0);
          save(); renderTable();
          toast(e.message);
        }
      };

      inp.addEventListener('keydown', e=>{
        if(e.key==='Enter'){ e.preventDefault(); commit(); }
        if(e.key==='Escape'){ e.preventDefault(); cancel(); }
      });
      inp.addEventListener('blur', commit);
    }

    // ========================
    // Import / Paste / Export
    // ========================
    $('btnImport').addEventListener('click', ()=> $('#fileImport').click());
    $('#fileImport').addEventListener('change', async ev=>{
      const f=ev.target.files[0]; if(!f) return; await handleFile(f); ev.target.value='';
    });

    $('btnPaste').addEventListener('click', ()=>{ $('#pasteArea').value=''; show('pasteModal', true); });
    $('btnPasteCancel').addEventListener('click', ()=> show('pasteModal', false));
    $('btnPasteApply').addEventListener('click', ()=>{
      const text=$('#pasteArea').value||''; if(!text.trim()){ toast('Nothing to import'); return; }
      const rows=parseDelimitedSmart(text); const items=rowsToItems(rows);
      if(!items.length){ toast('Could not detect headers or rows'); return; }
      show('pasteModal', false);
      showPreview(items);
    });

    const drop=$('#dropZone');
    drop.addEventListener('dragover', e=>{ e.preventDefault(); drop.style.background='#0e1621'; });
    drop.addEventListener('dragleave', ()=>{ drop.style.background=''; });
    drop.addEventListener('drop', async e=>{
      e.preventDefault(); drop.style.background=''; const f=e.dataTransfer.files[0]; if(f) await handleFile(f);
    });

    $('#fileImportModal').addEventListener('change', async ev=>{ const f=ev.target.files[0]; if(f) await handleFile(f); ev.target.value=''; });

    async function handleFile(f){
      try{
        const items=await parseAnyFile(f);
        if(!items.length){ toast('No rows found in file'); return; }
        show('pasteModal', false);
        showPreview(items);
      }catch(err){ toast(err.message||'Import failed'); }
    }
    function buildPreview(imported){
      const index=new Map(state.items.map(it=>[toKey(it.name), it]));
      const rows=[]; let add=0, upd=0, same=0;
      for(const r of imported){
        const k=toKey(r.name); if(!k) continue;
        const it=index.get(k);
        if(!it){ rows.push({name:r.name, desc:r.desc||'', oldQty:'â€”', newQty:toInt(r.qty,0), action:'Add'}); add++; }
        else{
          const oldQ=toInt(it.qty,0), newQ=toInt(r.qty,0);
          const act = (oldQ===newQ && (r.desc||'').trim()===String(it.desc||'').trim())? 'No change' : 'Update';
          if(act==='Update') upd++; else same++;
          rows.push({name:it.name, desc:(r.desc||it.desc||''), oldQty:oldQ, newQty:newQ, action:act});
        }
      }
      return {rows, add, upd, same, total: imported.length};
    }
    function showPreview(imported){
      const pv=buildPreview(imported);
      const info=$('previewInfo'); if(info){ info.textContent = `${pv.total} row(s): ${pv.add} add, ${pv.upd} update, ${pv.same} unchanged`; }
      const tbody=$('previewBody'); if(tbody){
        tbody.innerHTML='';
        for(const r of pv.rows){
          const tr=document.createElement('tr');
          tr.innerHTML =
            `<td style="padding:8px;border-bottom:1px solid var(--border)">${escapeHtml(r.name)}</td>`+
            `<td style="padding:8px;border-bottom:1px solid var(--border)">${escapeHtml(r.desc||'')}</td>`+
            `<td style="padding:8px;border-bottom:1px solid var(--border);text-align:right">${r.oldQty}</td>`+
            `<td style="padding:8px;border-bottom:1px solid var(--border);text-align:right">${r.newQty}</td>`+
            `<td style="padding:8px;border-bottom:1px solid var(--border)">${r.action}</td>`;
          tbody.appendChild(tr);
        }
      }
      state._pendingImport = imported;
      show('previewModal', true);
    }
    $('btnPreviewCancel').addEventListener('click', ()=>{ state._pendingImport=null; show('previewModal', false); });
    $('btnPreviewApply').addEventListener('click', async ()=>{
      const imp = state._pendingImport||[]; state._pendingImport=null; show('previewModal', false);
      if(!imp.length){ toast('Nothing to import'); return; }

      // Build optimistic merge (set semantics): add new or set qty/desc on existing
      const snap = snapshotItems();
      try{
        const index=new Map(state.items.map(it=>[toKey(it.name), it]));
        for(const r of imp){
          const k=toKey(r.name); if(!k) continue;
          const ex=index.get(k);
          const name=String(r.name||'').trim();
          const desc=String(r.desc||'').trim();
          const qty =toInt(r.qty,0);
          if(!ex){
            const it={ id:crypto.randomUUID(), name, desc, qty };
            state.items.push(it); index.set(k,it);
          }else{
            if(desc) ex.desc = desc;
            ex.qty = qty;
          }
        }
        dedupe(); setUpdated(); save(); render();

        if(SB.ready){
          await sbUpsertMany(imp);
        }
        toast('Import applied');
      }catch(e){
        // rollback on failure
        state.items = snap; save(); render();
        toast(e.message || 'Import failed');
      }
    });

    $('btnExportCsv').addEventListener('click', ()=>{
      const rows=[["Item","Description","Qty"]];
      for(const it of state.items){ rows.push([it.name||'', it.desc||'', String(toInt(it.qty,0))]); }
      const csv = rows.map(r=> r.map(v=> '"'+String(v).replace(/"/g,'""')+'"').join(',')).join('\n');
      const blob=new Blob([csv],{type:'text/csv;charset=utf-8'});
      const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='inventory.csv'; a.click(); URL.revokeObjectURL(url);
    });

    // Add-one modal
    $('btnAddOne').addEventListener('click', ()=>{ show('addOneModal', true); $('addName').focus(); });
    $('btnAddCancel').addEventListener('click', ()=> show('addOneModal', false));
    $('btnAddSave').addEventListener('click', saveAddOne);
    $('addQty').addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); saveAddOne(); }});
    async function saveAddOne(){
      const name = String(($('addName').value||'').trim());
      const desc = String(($('addDesc').value||'').trim());
      const qty  = toInt($('addQty').value,-1);
      if(!name){ toast('Item name required'); return; }
      if(qty<=0){ toast('Qty must be > 0'); return; }

      // Optimistic add
      const snap = snapshotItems();
      const newId = crypto.randomUUID();
      if(state.items.some(x=> toKey(x.name)===toKey(name))){ toast('Duplicate item'); return; }
      state.items.push({id:newId, name, desc, qty});
      setUpdated(); save();
      insertRowSorted({id:newId, name, desc, qty});
      ensureEmptyState();   

      try{
        if(SB.ready){
          // send same id so realtime doesn't duplicate (if you prefer server-generated ids, adjust accordingly)
          const { error } = await SB.client.from('items').insert([{ id:newId, name, description:desc||'', qty }]);
          if(error) throw error;
        }
      }catch(e){
        // rollback on failure
        state.items = snap; save(); render();
        toast(e.message || 'Cloud add failed');
        return;
      }
      $('addName').value=''; $('addDesc').value=''; $('addQty').value='';
      show('addOneModal', false);
      toast('Item added');
    }

    // Delete selected rows (optimistic UI with rollback on error)
    $('btnDeleteSelected').addEventListener('click', async ()=>{
      const boxes = Array.from(document.querySelectorAll('.rowChk:checked'));
      if (boxes.length === 0) { toast('No items selected'); return; }
      if (!confirm(`Delete ${boxes.length} item(s)?`)) return;

      const ids = boxes.map(b => b.dataset.id).filter(Boolean);

      // Optimistic UI: remove locally right away, keep snapshot to roll back on failure
      const snapshot = state.items.slice();
      state.items = state.items.filter(it => !ids.includes(it.id));
      setUpdated(); save();
      ids.forEach(id => { const tr = rowElById(id); if(tr && tr.parentNode) tr.parentNode.removeChild(tr); });
      ensureEmptyState();

      try {
        if (SB.ready) {
          const res = await sbDeleteMany(ids);
          // One-time reconciliation to ensure both devices are consistent
          await sbLoadSnapshot();
          toast('Deleted '+res.deleted+'/'+res.requested);
        } else {
          toast('Deleted');
        }
        const m = $('chkAll'); if (m) { m.checked = false; m.indeterminate = false; }
      } catch (e) {
        // rollback on error
        state.items = snapshot; save(); renderTable(); // full redraw only on rollback
        toast(e.message || 'Delete failed');
      }
    });

    // Master checkbox + indeterminate state
    document.addEventListener('change', (e)=>{
      if(e.target && e.target.id==='chkAll'){
        const on = e.target.checked;
        document.querySelectorAll('.rowChk').forEach(cb=> cb.checked=on);
      }
      if(e.target && e.target.classList && e.target.classList.contains('rowChk')){
        const all = document.querySelectorAll('.rowChk');
        const checked = document.querySelectorAll('.rowChk:checked');
        const m = $('chkAll');
        if(m){
          m.checked = (checked.length===all.length && all.length>0);
          m.indeterminate = (checked.length>0 && checked.length<all.length);
        }
        if (state._filter) {
          state._filter = '';
          const fb = $('filterBox'); if (fb) fb.value = '';
          renderTable();
        }
      }
    });

    // ========================
    // Parsing helpers
    // ========================
    function parseDelimitedSmart(text){
      const firstLine=(text.split(/\r?\n/)[0]||'');
      let delim='\t';
      const tabScore=(firstLine.split('\t').length-1);
      const commaScore=(firstLine.split(',').length-1);
      const spaceScore=((firstLine.match(/\s{2,}/g)||[]).length);
      if(commaScore>tabScore && commaScore>=spaceScore) delim=','; else if(spaceScore>tabScore && spaceScore>commaScore) delim='  ';

      const rows=[]; let row=[]; let field=''; let inQ=false; let i=0; const N=text.length;
      const isDelim=(ch,pk)=> delim==='\t'? ch==='\t' : (delim===','? ch===',' : (ch===' ' && pk===' '));
      while(i<N){
        const ch=text[i], pk=text[i+1];
        if(ch==='"'){ if(inQ && pk==='"'){ field+='"'; i+=2; continue; } inQ=!inQ; i++; continue; }
        if(!inQ && (isDelim(ch,pk) || ch==='\n')){
          row.push(field); field='';
          if(delim==='  ' && ch===' ' && pk===' '){ while(text[i]===' ') i++; continue; }
          if(ch==='\n'){ rows.push(row); row=[]; }
          i++; continue;
        }
        if(ch==='\r'){ i++; continue; }
        field+=ch; i++;
      }
      if(field.length||row.length){ row.push(field); rows.push(row); }
      return rows.filter(r=> r.some(c=> String(c).trim().length));
    }
    function rowsToItems(rows){
      if(!rows||!rows.length) return [];
      const canon=s=> toKey(String(s).replace(/[^A-Za-z0-9]+/g,'').trim());
      const hdrsRaw=rows[0]||[]; const hdrs=hdrsRaw.map(canon);
      const idxFromHdr=names=>{ for(const n of names){ const i=hdrs.indexOf(n); if(i>=0) return i; } return -1; };
      let iItem=idxFromHdr(['ITEM','NAME']);
      let iDesc=idxFromHdr(['DESCRIPTION','DESC']);
      let iQty = idxFromHdr(['QTY','QUANTITY','COUNT','QUANTITYONHAND']);
      const hasHeader=(iItem>=0);
      if(!hasHeader){ iItem=0; iDesc=1; iQty=2; }
      const start=hasHeader?1:0; const out=[];
      for(let r=start;r<rows.length;r++){
        const row=rows[r]||[];
        const name=String((row[iItem]!==undefined? row[iItem] : '')).trim(); if(!name) continue;
        const desc=String((iDesc>=0 && row[iDesc]!==undefined? row[iDesc] : '')).trim();
        const qtyV=(iQty>=0 && row[iQty]!==undefined)? row[iQty] : 0; const qty=toInt(qtyV,0);
        out.push({name, desc, qty});
      }
      return out;
    }
    async function ensureXlsx(){
      if(window.XLSX) return;
      await new Promise((res,rej)=>{
        const s=document.createElement('script');
        s.src='https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js';
        s.onload=res; s.onerror=()=>rej(Error('Failed to load XLSX parser'));
        document.head.appendChild(s);
      });
    }
    async function ensureDocx(){
      if(window.mammoth) return;
      await new Promise((res,rej)=>{
        const s=document.createElement('script');
        s.src='https://cdn.jsdelivr.net/npm/mammoth@1.6.0/mammoth.browser.min.js';
        s.onload=res; s.onerror=()=>rej(Error('Failed to load DOCX parser'));
        document.head.appendChild(s);
      });
    }
    async function parseDocx(file){
      await ensureDocx();
      const buf = await file.arrayBuffer();
      const result = await window.mammoth.convertToHtml({arrayBuffer: buf});
      const html = result && result.value ? result.value : '';
      if(!html) return [];
      const tmp = document.createElement('div'); tmp.innerHTML = html;
      const tables = tmp.querySelectorAll('table');
      const items = [];
      if(tables.length){
        tables.forEach(tbl=>{
          const rows = Array.from(tbl.querySelectorAll('tr'))
            .map(tr => Array.from(tr.children).map(td => td.textContent.trim()));
          const parsed = rowsToItems(rows);
          parsed.forEach(r=> items.push(r));
        });
        if(items.length) return items;
      }
      const lines = Array.from(tmp.querySelectorAll('p'))
        .map(p=> p.textContent.replace(/\u00a0/g,' ').trim())
        .filter(s=> s.length);
      if(lines.length){
        if(lines.some(l=>/[\t,]/.test(l))){
          const text = lines.join('\n');
          return rowsToItems(parseDelimitedSmart(text));
        }
        const rows = [];
        for(let i=0;i<lines.length;i++){
          const a = lines[i];
          const b = (i+1 < lines.length) ? lines[++i] : '';
          rows.push([a, b, '0']);
        }
        return rowsToItems(rows);
      }
      return [];
    }
    async function parseAnyFile(file){
      const ext=(file.name.split('.').pop()||'').toLowerCase();
      if(ext==='json'){
        const t=await file.text();
        try{
          const p=JSON.parse(t);
          if(Array.isArray(p.items)) return p.items.map(it=>({name:String(it.name||'').trim(), desc:String(it.desc||''), qty:toInt(it.qty,0)}));
          if(Array.isArray(p)) return p.map(it=>({name:String(it.Item||it.name||'').trim(), desc:String(it.Description||it.desc||''), qty:toInt(it.Qty||it.qty,0)}));
        }catch{}
        return [];
      }
      if(ext==='docx' || ext==='doc'){ try { return await parseDocx(file); } catch{ return []; } }
      if(ext==='csv'||ext==='tsv'||ext==='txt'){ const t=await file.text(); return rowsToItems(parseDelimitedSmart(t)); }
      if(ext==='xlsx'||ext==='xls'){
        await ensureXlsx();
        const buf=await file.arrayBuffer();
        const wb=XLSX.read(buf,{type:'array'});
        const ws=wb.Sheets[wb.SheetNames[0]];
        const aoa=XLSX.utils.sheet_to_json(ws,{header:1,raw:true});
        return rowsToItems(aoa);
      }
      return [];
    }

    // ========================
    // Merge semantics (local mode)
    // ========================
    function mergeSet(imported){
      const index=new Map(state.items.map(it=>[toKey(it.name), it]));
      let added=0, updated=0;
      for(const r of imported){
        const k=toKey(r.name); if(!k) continue;
        let it=index.get(k);
        if(!it){
          it={id:crypto.randomUUID(), name:r.name.trim(), desc:(r.desc||'').trim(), qty:toInt(r.qty,0)};
          state.items.push(it); index.set(k,it); added++;
        }else{
          if(r.desc && r.desc.trim()) it.desc=r.desc.trim();
          it.qty=toInt(r.qty,0);
          updated++;
        }
      }
      dedupe(); setUpdated(); save();
      return {added, updated, total:imported.length};
    }

    // ========================
    // Utilities
    // ========================
    function show(id, on = true) {
  const el = document.getElementById(id);
  if (!el) return;
  if (!on) {
    // If we're hiding, and focus is inside the modal, blur it first
    if (el.contains(document.activeElement)) {
      document.activeElement.blur();
    }
    el.setAttribute('aria-hidden', 'true');
    el.style.display = 'none';
    return;
  }
  // Show and make it accessible
  el.style.display = 'block';
  el.setAttribute('aria-hidden', 'false');

  // Optional: auto-focus a sensible control
  if (id === 'addOneModal') {
    const inp = document.getElementById('addName');
    if (inp) setTimeout(() => inp.focus(), 0);
  } else if (id === 'pasteModal') {
    const ta = document.getElementById('pasteArea');
    if (ta) setTimeout(() => ta.focus(), 0);
  }
}
    function toast(msg){ const t=$('toast'); t.textContent=msg; t.style.display='block'; clearTimeout(t._tmr); t._tmr=setTimeout(()=> t.style.display='none', 2000); }

    // iOS keyboard-safe scroll height
    document.addEventListener('focusin', (e)=>{
      if(e.target.matches('input,textarea')){
        document.querySelector('.scroll')?.style.setProperty('max-height','60vh');
      }
    });
    document.addEventListener('focusout', (e)=>{
      if(e.target.matches('input,textarea')){
        document.querySelector('.scroll')?.style.setProperty('max-height','70vh');
      }
    });

    // Boot
    document.addEventListener('DOMContentLoaded', async ()=>{
      load(); dedupe(); save(); render();
      const fb=$('filterBox'); if(fb){ fb.value=state._filter||''; fb.addEventListener('input', ()=>{ state._filter=fb.value; renderTable(); }); }

      // Supabase: if URL/key provided, initialize + load + subscribe
      sbInit();
      if(SB.ready){ await sbLoadSnapshot(); sbStartRealtime(); }

      if('serviceWorker' in navigator){
        navigator.serviceWorker.register('./sw.js?v=10', { scope: './' }).catch(console.warn);      }
    });
  </script>
</body>
</html>